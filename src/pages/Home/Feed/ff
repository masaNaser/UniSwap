اسمع بتقدر تساعدني انه اظهر صورة اليوزر اللي عمل تعليق : // // src/utils/imageHelper.js

// const BASE_URL = import.meta.env.VITE_API_URL || "https://uni.runasp.net";

// export const getImageUrl = (path) => {
//   if (!path) return null;
//   if (path.startsWith('http')) return path;
//   return `${BASE_URL}${path}`;
// };

// src/utils/imageHelper.js

const BASE_URL = import.meta.env.VITE_API_URL || "https://uni.runasp.net";

export const getImageUrl = (path, fallbackName = "User") => {
  // إذا ما في صورة (null)، رجّع صورة افتراضية بأول حرفين من الاسم
  if (!path) {
    // أخذ أول حرفين من الاسم
    const initials = fallbackName
      .split(' ')
      .slice(0, 2)  // أول كلمتين
      .map(word => word[0])  // أول حرف من كل كلمة
      .join('')
      .toUpperCase();
    
    return `https://ui-avatars.com/api/?name=${encodeURIComponent(initials)}&background=4A90E2&color=fff&size=200&bold=true&length=2`;
  }
  
  // إذا في صورة وهي full URL
  if (path.startsWith('http')) return path;
  
  // إذا في صورة وهي relative path
  return `${BASE_URL}${path}`;
};  
import React, { useEffect, useState, useCallback } from "react";
import { 
    Container, 
    Box, 
    Dialog, 
    DialogTitle, 
    DialogContent, 
    DialogActions, 
    TextField, 
    Button,
    Snackbar,
    Alert,
    CircularProgress,
} from "@mui/material";
import { WavingHand } from "@mui/icons-material";
import WarningAmberIcon from "@mui/icons-material/WarningAmber";
import SelectActionCard from "../../../components/Cards/Cards";
import AccessTimeIcon from "@mui/icons-material/AccessTime";
import WorkspacePremiumOutlinedIcon from "@mui/icons-material/WorkspacePremiumOutlined";
import GroupIcon from "@mui/icons-material/Group";
import CreatePost from "./CreatePost";
import PostCard from "./PostCard";
import Sidebar from "./Sidebar";
import "./Feed.css";
import CommentsModal from './CommentsModal';
import {
    getPosts as getPostsApi,
    deletePost as deletePostApi,
    editPost as editPostApi,
    likePost as likePostApi,
    unlikePost as unlikePostApi,
    getComments as getCommentsApi,
    addComment as addCommentApi,
    deleteComment as deleteCommentApi,
    editComment as editCommentApi,
} from "../../../services/postService";
import ProfilePic from "../../../assets/images/ProfilePic.jpg";
import dayjs from 'dayjs';
import { getImageUrl } from "../../../utils/imageHelper"; // أضف هذا

// normalize comment
const normalizeComment = (comment, userName) => ({
    id: comment.id,
    content: comment.content,
    createdAt: comment.createdAt,
    authorId: comment.user?.id, // إضافة الـ authorId
    author: {
        userName: comment.user?.userName,
        avatar: getImageUrl(comment.user?.profilePictureUrl, comment.user?.userName), // ✅ هنا
    }
});

// update post by ID
const updatePost = (posts, postId, newData) =>
    posts.map(p => (p.id === postId ? { ...p, ...newData } : p));

function Feed() {
    const [posts, setPosts] = useState([]);
    const userToken = localStorage.getItem("accessToken");
    const userName = localStorage.getItem("userName");

    const [commentsModalVisible, setCommentsModalVisible] = useState(false);
    const [currentPostId, setCurrentPostId] = useState(null);
    const [currentComments, setCurrentComments] = useState([]);
    const [modalPost, setModalPost] = useState(null);
    const [userIdCommenting, setUserIdCommenting] = useState(null);
    // Delete Dialog State
    const [deleteDialog, setDeleteDialog] = useState({
        open: false,
        postId: null,
    });

    // Edit Dialog State
    const [editDialog, setEditDialog] = useState({
        open: false,
        postId: null,
        content: "",
        tags: "",
        file: null,
        existingFileUrl: "",
        previewUrl: "",
    });

    const [isUpdating, setIsUpdating] = useState(false);

    // Snackbar State
    const [snackbar, setSnackbar] = useState({
        open: false,
        message: "",
        severity: "success",
    });

    // Handle Snackbar Close
    const handleSnackbarClose = () => {
        setSnackbar({ ...snackbar, open: false });
    };

    const fetchPosts = async () => {
        try {
            const response = await getPostsApi(userToken);
            console.log(response);
            const postsData = response.data.map(p => ({
                id: p.id,
                content: p.content,
                selectedTags: p.tags?.[0]?.split(",") || [],
                user: { name: p.author.userName, avatar: getImageUrl(p.author.profilePictureUrl, p.author.userName), id: p.author.id },
                time: dayjs(p.createdAt).format('DD MMM, hh:mm A'),
                likes: p.likesCount,
                comments: p.commentsCount,
                shares: 0,
                fileUrl: p.fileUrl ? `https://uni.runasp.net/${p.fileUrl}` : null,
                isLiked: p.isLikedByMe || false,
                recentComments: [],
            }));
            setPosts(postsData);
        } catch (error) {
            setSnackbar({
                open: true,
                message: "Failed to fetch posts.",
                severity: "error",
            });
            console.error("Error fetching posts:", error);
        }
    };

    const fetchRecentComments = useCallback(async (postId) => {
        try {
            const response = await getCommentsApi(userToken, postId);
            setUserIdCommenting(response.data[0]?.user?.id || null);
            if (response.data?.length) {
                return response.data
                    .sort((a, b) => dayjs(b.createdAt).valueOf() - dayjs(a.createdAt).valueOf())
                    .slice(0, 2)
                    .map(c => normalizeComment(c, userName));
            }
            return [];
        } catch (error) {
            console.error("Error fetching recent comments:", error);
            return [];
        }
    }, [userToken, userName]);

    useEffect(() => {
        if (posts.length) {
            posts.forEach(async post => {
                if (post.comments > 0 && post.recentComments.length === 0) {
                    const recentComments = await fetchRecentComments(post.id);
                    setPosts(prev => updatePost(prev, post.id, { recentComments }));
                }
            });
        }
    }, [posts.length, fetchRecentComments]);

    const addPost = (newPost) =>
        setPosts([{ ...newPost, isLiked: false, recentComments: [] }, ...posts]);

    // Open Delete Dialog
    const openDeleteDialog = (postId) => {
        setDeleteDialog({ open: true, postId });
    };

    // Close Delete Dialog
    const closeDeleteDialog = () => {
        setDeleteDialog({ open: false, postId: null });
    };

    // Confirm Delete Post
    const handleDeletePost = async () => {
        const postId = deleteDialog.postId;
        closeDeleteDialog();

        try {
            const response = await deletePostApi(userToken, postId);
            if (response.status === 204) {
                setPosts(posts.filter(p => p.id !== postId));
                setSnackbar({
                    open: true,
                    message: "Your post has been deleted. ✓",
                    severity: "success",
                });
            }
        } catch (error) {
            console.error("Error deleting post:", error);
            setSnackbar({
                open: true,
                message: "Failed to delete post. Please try again.",
                severity: "error",
            });
        }
    };

    // Open Edit Dialog
    const openEditDialog = (postId) => {
        const postToEdit = posts.find(p => p.id === postId);
        if (!postToEdit) return;

        setEditDialog({
            open: true,
            postId,
            content: postToEdit.content,
            tags: postToEdit.selectedTags.join(","),
            file: null,
            existingFileUrl: postToEdit.fileUrl || "",
            previewUrl: postToEdit.fileUrl || "",
        });
    };

    // Close Edit Dialog
    const closeEditDialog = () => {
        setEditDialog({
            open: false,
            postId: null,
            content: "",
            tags: "",
            file: null,
            existingFileUrl: "",
            previewUrl: "",
        });
    };

    // Handle File Change in Edit Dialog
    const handleEditFileChange = (e) => {
        const file = e.target.files[0];
        if (file) {
            setEditDialog(prev => ({
                ...prev,
                file,
                previewUrl: URL.createObjectURL(file),
            }));
        }
    };

    // Confirm Edit Post
    const handleEditPost = async () => {
        const { postId, content, tags, file } = editDialog;
        
        setIsUpdating(true);

        try {
            const formData = new FormData();
            formData.append("Content", content);
            formData.append("Tags", tags);
            if (file) formData.append("File", file);

            const response = await editPostApi(formData, userToken, postId);
            console.log(response);

            if (response.status === 204) {
                const postToEdit = posts.find(p => p.id === postId);
                const updatedPost = {
                    ...postToEdit,
                    content,
                    selectedTags: tags ? tags.split(",") : [],
                    time: new Date().toLocaleString(),
                    fileUrl: file ? URL.createObjectURL(file) : postToEdit.fileUrl,
                };
                setPosts(prev => updatePost(prev, postId, updatedPost));
                
                closeEditDialog();
                setSnackbar({
                    open: true,
                    message: "Your post has been updated. ✓",
                    severity: "success",
                });
            }
        } catch (error) {
            console.error("Error editing post:", error);
            setSnackbar({
                open: true,
                message: "Failed to update post.",
                severity: "error",
            });
        } finally {
            setIsUpdating(false);
        }
    };

    const handleLikePost = async (postId) => {
        const postToUpdate = posts.find(p => p.id === postId);
        if (!postToUpdate) return;

        const isCurrentlyLiked = postToUpdate.isLiked;
        const originalLikes = postToUpdate.likes;

        setPosts(prev => updatePost(prev, postId, { isLiked: !isCurrentlyLiked, likes: isCurrentlyLiked ? originalLikes - 1 : originalLikes + 1 }));

        try {
            const response = isCurrentlyLiked
                ? await unlikePostApi(userToken, postId)
                : await likePostApi(userToken, postId);

            if (response.data?.likesCount !== undefined) {
                setPosts(prev => updatePost(prev, postId, { isLiked: response.data.isLikedByMe || !isCurrentlyLiked, likes: response.data.likesCount }));
            }
        } catch (error) {
            console.error(`Error ${isCurrentlyLiked ? 'unliking' : 'liking'} post:`, error);
            setPosts(prev => updatePost(prev, postId, { isLiked: isCurrentlyLiked, likes: originalLikes }));
            setSnackbar({
                open: true,
                message: `Failed to ${isCurrentlyLiked ? 'unlike' : 'like'} post.`,
                severity: "error",
            });
        }
    };

    const handleShowComments = async (postId) => {
        const post = posts.find(p => p.id === postId);
        if (!post) return;

        setCurrentPostId(postId);
        setModalPost(post);
        setCommentsModalVisible(true);
        setCurrentComments([]);

        try {
            const response = await getCommentsApi(userToken, postId);
        console.log("Comments fetched:",response.data);
            const sortedComments = response.data
                .map(comment => normalizeComment(comment, userName))
                .sort((a, b) => dayjs(b.createdAt).valueOf() - dayjs(a.createdAt).valueOf());
            setCurrentComments(sortedComments);
            console.log("Sorted Comments:",sortedComments);
        } catch (error) {
            console.error("Error fetching comments:", error);
            setSnackbar({
                open: true,
                message: "Failed to load comments.",
                severity: "error",
            });
            setCommentsModalVisible(false);
            setModalPost(null);
        }

    }
    const handleAddComment = async (postId, content) => {
        const tempCommentId = Date.now();
        const currentUserId = localStorage.getItem("userId"); // أو من أي مكان تاني عندك الـ userId
        const currentUserAvatar = getImageUrl(null, userName); // صورة افتراضية
        const newComment = { id: tempCommentId,
             content,
              createdAt: new Date().toISOString(),
               author:
                {
                 userName, 
                 avatar: currentUserAvatar // ✅ هنا
                },
                authorId: currentUserId,
            };

        // Update modal and posts instantly
        if (currentPostId === postId) setCurrentComments(prev => [newComment, ...prev]);
        setPosts(prev => prev.map(p => p.id === postId ? { ...p, comments: p.comments + 1, recentComments: [newComment, ...p.recentComments].slice(0, 2) } : p));

        try {
            const response = await addCommentApi(userToken, postId, content);
            if (response.data?.id) {
                const finalComment = normalizeComment(response.data, userName);
                setCurrentComments(prev => prev.map(c => c.id === tempCommentId ? finalComment : c));
                setPosts(prev => prev.map(p => p.id === postId ? { ...p, recentComments: [finalComment, ...p.recentComments.filter(c => c.id !== tempCommentId)].slice(0, 2) } : p));
            }
        } catch (error) {
            console.error("Error adding comment:", error);
            setSnackbar({
                open: true,
                message: "Failed to add comment.",
                severity: "error",
            });
            setCurrentComments(prev => prev.filter(c => c.id !== tempCommentId));
            setPosts(prev => prev.map(p => p.id === postId ? { ...p, comments: p.comments - 1, recentComments: p.recentComments.filter(c => c.id !== tempCommentId) } : p));
        }
    };

    const handleDeleteComment = async (commentId) => {
        const postId = currentPostId;
        const originalComments = currentComments;
        setCurrentComments(prev => prev.filter(c => c.id !== commentId));

        let shouldRefetchRecent = false;
        let originalRecentComments = [];

        setPosts(prev => prev.map(p => {
            if (p.id === postId) {
                originalRecentComments = p.recentComments;
                if (p.recentComments.some(c => c.id === commentId)) shouldRefetchRecent = true;
                return { ...p, comments: p.comments - 1, recentComments: p.recentComments.filter(c => c.id !== commentId) };
            }
            return p;
        }));

        try {
            await deleteCommentApi(userToken, commentId);
            if (shouldRefetchRecent) {
                const newRecentComments = await fetchRecentComments(postId);
                setPosts(prev => updatePost(prev, postId, { recentComments: newRecentComments }));
            }
        } catch (error) {
            console.error("Error deleting comment:", error);
            if (error.response?.status !== 404) {
                setSnackbar({
                    open: true,
                    message: "Failed to delete comment.",
                    severity: "error",
                });
                setCurrentComments(originalComments);
                setPosts(prev => updatePost(prev, postId, { comments: originalRecentComments.length, recentComments: originalRecentComments }));
            }
        }
    };

    const handleEditComment = async (commentId, newContent) => {
        const originalComments = [...currentComments];
        const originalComment = originalComments.find(c => c.id === commentId);
        const originalContent = originalComment?.content;
        const postId = currentPostId;

        setCurrentComments(prev => prev.map(c => c.id === commentId ? { ...c, content: newContent, createdAt: new Date().toISOString() } : c));
        setPosts(prev => prev.map(p => p.id === postId ? { ...p, recentComments: p.recentComments.map(c => c.id === commentId ? { ...c, content: newContent, createdAt: new Date().toISOString() } : c) } : p));

        try {
            await editCommentApi(userToken, commentId, newContent);
        } catch (error) {
            console.error("Error editing comment:", error);
            setCurrentComments(originalComments);
            setPosts(prev => prev.map(p => p.id === postId ? { ...p, recentComments: p.recentComments.map(c => c.id === commentId ? { ...c, content: originalContent, createdAt: originalComment.createdAt } : c) } : p));
            setSnackbar({
                open: true,
                message: "Failed to update comment.",
                severity: "error",
            });
        }
    };

    useEffect(() => { fetchPosts(); }, [userToken]);

    return (
        <>
            <Container maxWidth="lg" className="container">
                <div className="welcome-section">
                    <h1 className="welcome-heading">
                        Welcome back, {userName}! <WavingHand className="wave" />
                    </h1>
                    <p className="welcome-subheading">
                        Here's what's happening in your community today.
                    </p>
                </div>

                <div className="cards-section">
                    <SelectActionCard title="Active Services" value="12" icon={<AccessTimeIcon />} />
                    <SelectActionCard title="Completed Tasks" value="47" icon={<WorkspacePremiumOutlinedIcon />} />
                    <SelectActionCard title="Peer Rating" value="4.8" icon={<GroupIcon />} />
                </div>

                <div className="post-section">
                    <div className="create-post-main">
                        <CreatePost addPost={addPost} token={userToken} />
                        <Box mt={3}>
                            {posts.map(post => (
                                <PostCard
                                    key={post.id}
                                    post={post}
                                    onDelete={openDeleteDialog}
                                    onEdit={openEditDialog}
                                    onLike={handleLikePost}
                                    onShowComments={handleShowComments}
                                    onAddCommentInline={handleAddComment}
                                    fetchRecentComments={fetchRecentComments}
                                />
                            ))}
                        </Box>
                    </div>
                    <div className="feed-sidebar" style={{ flex: 1 }}>
                        <Sidebar />
                    </div>
                </div>

                <CommentsModal
                    isVisible={commentsModalVisible}
                    onClose={() => setCommentsModalVisible(false)}
                    comments={currentComments}
                    postId={currentPostId}
                    post={modalPost}
                    onCommentSubmit={handleAddComment}
                    onDeleteComment={handleDeleteComment}
                    onEditComment={handleEditComment}
                    currentUserName={userName}
                />
            </Container>

            {/* Delete Confirmation Dialog */}
            <Dialog
                open={deleteDialog.open}
                onClose={closeDeleteDialog}
                PaperProps={{
                    sx: {
                        borderRadius: "12px",
                        width: "400px",
                        maxWidth: "90%",
                    },
                }}
            >
                <DialogTitle sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                    <WarningAmberIcon sx={{ color: "#F59E0B" }} />
                    Delete Post
                </DialogTitle>
                <DialogContent>
                    <Box sx={{ pt: 1 }}>
                        Are you sure you want to delete this post?
                    </Box>
                </DialogContent>
                <DialogActions sx={{ px: 3, pb: 2 }}>
                    <Button
                        onClick={closeDeleteDialog}
                        sx={{
                            color: "#6B7280",
                            textTransform: "none",
                        }}
                    >
                        No, keep it
                    </Button>
                    <Button
                        onClick={handleDeletePost}
                        variant="contained"
                        sx={{
                            bgcolor: "#EF4444",
                            textTransform: "none",
                            "&:hover": {
                                bgcolor: "#DC2626",
                            },
                        }}
                    >
                        Yes, delete it!
                    </Button>
                </DialogActions>
            </Dialog>

            {/* Edit Post Dialog */}
            <Dialog
                open={editDialog.open}
                onClose={closeEditDialog}
                maxWidth="sm"
                fullWidth
                PaperProps={{
                    sx: {
                        borderRadius: "12px",
                    },
                }}
            >
                <DialogTitle>Edit Post</DialogTitle>
                <DialogContent sx={{ pt: 2 }}>
                    <TextField
                        fullWidth
                        multiline
                        rows={4}
                        label="Content"
                        value={editDialog.content}
                        onChange={(e) => setEditDialog(prev => ({ ...prev, content: e.target.value }))}
                        sx={{ mb: 2 }}
                    />
                    <TextField
                        fullWidth
                        label="Tags (comma separated)"
                        value={editDialog.tags}
                        onChange={(e) => setEditDialog(prev => ({ ...prev, tags: e.target.value }))}
                        sx={{ mb: 2 }}
                    />
                    <input
                        type="file"
                        accept="image/*"
                        onChange={handleEditFileChange}
                        style={{ marginBottom: "16px" }}
                    />
                    {editDialog.previewUrl && (
                        <Box sx={{ mt: 2, textAlign: "center" }}>
                            <img
                                src={editDialog.previewUrl}
                                alt="Preview"
                                style={{
                                    width: "50%",
                                    maxHeight: "200px",
                                    objectFit: "cover",
                                    borderRadius: "8px",
                                }}
                            />
                        </Box>
                    )}
                </DialogContent>
                <DialogActions sx={{ px: 3, pb: 2 }}>
                    <Button
                        onClick={closeEditDialog}
                        disabled={isUpdating}
                        sx={{
                            color: "#6B7280",
                            textTransform: "none",
                        }}
                    >
                        Cancel
                    </Button>
                    <Button
                        onClick={handleEditPost}
                        variant="contained"
                        disabled={isUpdating}
                        sx={{
                            bgcolor: "#3B82F6",
                            textTransform: "none",
                            minWidth: "100px",
                            "&:hover": {
                                bgcolor: "#2563EB",
                            },
                        }}
                    >
                        {isUpdating ? <CircularProgress size={20} color="inherit" /> : "Save"}
                    </Button>
                </DialogActions>
            </Dialog>

            {/* Snackbar للإشعارات */}
            <Snackbar
                open={snackbar.open}
                autoHideDuration={3000}
                onClose={handleSnackbarClose}
                anchorOrigin={{ vertical: "top", horizontal: "center" }}
            >
                <Alert
                    onClose={handleSnackbarClose}
                    severity={snackbar.severity}
                    sx={{
                        width: "100%",
                        bgcolor: snackbar.severity === "success" ? "#3b82f6" : "#EF4444",
                        color: "white",
                        "& .MuiAlert-icon": {
                            color: "white",
                        },
                    }}
                    variant="filled"
                >
                    {snackbar.message}
                </Alert>
            </Snackbar>
        </>
    );
}

export default Feed;   

















import React, { useState } from "react";
import {
    Modal,
    Box,
    Typography,
    Divider,
    TextField,
    Button,
    Avatar,
    IconButton,
    CircularProgress,
    Chip,
    CardHeader,
    CardContent,
    Menu,
    MenuItem,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogContentText,
    DialogActions,
    Snackbar,
    Alert,
} from "@mui/material";
import SendIcon from "@mui/icons-material/Send";
import MoreVertIcon from "@mui/icons-material/MoreVert";
import EditIcon from "@mui/icons-material/Edit";
import DeleteIcon from "@mui/icons-material/Delete";
import WarningAmberIcon from "@mui/icons-material/WarningAmber";
import dayjs from "dayjs";
import { useNavigateToProfile } from "../../../hooks/useNavigateToProfile";
const style = {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: { xs: "95%", sm: 500, md: 600 },
    height: "90vh",
    bgcolor: "background.paper",
    borderRadius: 2,
    boxShadow: 24,
    display: "flex",
    flexDirection: "column",
};

// Helper function to format time
const formatTime = (time) => (time ? dayjs(time).format("DD MMM, hh:mm A") : "Just now");

const Comment = ({ comment, onEdit, onDelete, currentUserName }) => {
    const [anchorEl, setAnchorEl] = useState(null);
    const [isEditing, setIsEditing] = useState(false);
    const [editedContent, setEditedContent] = useState(comment.content);
    const [deleteDialog, setDeleteDialog] = useState(false);
   
    console.log("Current ",comment);
    const navigateToProfile = useNavigateToProfile();
    const isCurrentUser = comment.author.userName === currentUserName;
    const open = Boolean(anchorEl);

    const handleMenuClick = (event) => {
        event.stopPropagation();
        setAnchorEl(event.currentTarget);
    };

    const handleMenuClose = () => setAnchorEl(null);

    const handleEditClick = () => {
        setIsEditing(true);
        handleMenuClose();
    };

    const handleDeleteClick = () => {
        setDeleteDialog(true);
        handleMenuClose();
    };

    const handleConfirmDelete = () => {
        onDelete(comment.id);
        setDeleteDialog(false);
    };

    const handleCancelDelete = () => {
        setDeleteDialog(false);
    };

    const handleSaveEdit = () => {
        if (editedContent.trim() && editedContent !== comment.content) {
            onEdit(comment.id, editedContent.trim());
        }
        setIsEditing(false);
    };

    const handleCancelEdit = () => {
        setEditedContent(comment.content);
        setIsEditing(false);
    };

    return (
        <>
            <Box sx={{ display: "flex", gap: 1.5, my: 2 }}>
                <Avatar
                    src={comment.author.avatar}
                    onClick={() => navigateToProfile(comment.authorId)} // ← استخدم authorId من الـ comment
                    alt={comment.author.userName}
                    sx={{ width: 32, height: 32 }}
                />
                <Box sx={{ flexGrow: 1, minWidth: 0 }}>
                    {isEditing ? (
                        <Box>
                            <TextField
                                fullWidth
                                multiline
                                variant="outlined"
                                size="small"
                                value={editedContent}
                                onChange={(e) => setEditedContent(e.target.value)}
                                sx={{ mb: 1 }}
                            />
                            <Button
                                variant="contained"
                                size="small"
                                onClick={handleSaveEdit}
                                disabled={!editedContent.trim()}
                            >
                                Save
                            </Button>
                            <Button
                                variant="outlined"
                                size="small"
                                onClick={handleCancelEdit}
                                sx={{ ml: 1 }}
                            >
                                Cancel
                            </Button>
                        </Box>
                    ) : (
                        <Box
                            sx={{
                                bgcolor: "#f0f2f5",
                                borderRadius: "16px",
                                p: 1.5,
                                position: "relative",
                            }}
                        >
                            {
                            <Typography variant="body2" fontWeight="bold"
                                onClick={() => navigateToProfile(comment.authorId)} // ← استخدم authorId
                            sx={{ cursor: 'pointer' }}>
                                
                                {comment.author.userName}
                            </Typography>
}
                            <Typography variant="body2" sx={{ my: 0.5, pr: isCurrentUser ? 3 : 0 }}>
                                {comment.content}
                            </Typography>
                            <Typography
                                variant="caption"
                                color="text.secondary"
                                sx={{ display: "block", textAlign: "right", mt: 0.5, ml: 'auto' }}
                            >
                                {formatTime(comment.createdAt)}
                            </Typography>

                            {isCurrentUser && (
                                <IconButton
                                    aria-label="more"
                                    onClick={handleMenuClick}
                                    size="small"
                                    sx={{ position: 'absolute', top: 4, right: 4, p: 0 }}
                                >
                                    <MoreVertIcon fontSize="small" />
                                </IconButton>
                            )}
                        </Box>
                    )}
                </Box>

                <Menu
                    anchorEl={anchorEl}
                    open={open}
                    onClose={handleMenuClose}
                    MenuListProps={{ "aria-labelledby": "basic-button" }}
                >
                    <MenuItem onClick={handleEditClick}>
                        <EditIcon fontSize="small" sx={{ mr: 1 }} /> Edit
                    </MenuItem>
                    <MenuItem onClick={handleDeleteClick}>
                        <DeleteIcon fontSize="small" sx={{ mr: 1 }} /> Delete
                    </MenuItem>
                </Menu>
            </Box>

            {/* Delete Confirmation Dialog */}
            <Dialog
                open={deleteDialog}
                onClose={handleCancelDelete}
                PaperProps={{
                    sx: {
                        borderRadius: "12px",
                        width: "400px",
                        maxWidth: "90%",
                    },
                }}
            >
                <DialogTitle sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                    <WarningAmberIcon sx={{ color: "#F59E0B" }} />
                    Delete Comment
                </DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Are you sure you want to delete this comment? You won't be able to revert this!
                    </DialogContentText>
                </DialogContent>
                <DialogActions sx={{ px: 3, pb: 2 }}>
                    <Button
                        onClick={handleCancelDelete}
                        sx={{
                            color: "#6B7280",
                            textTransform: "none",
                        }}
                    >
                        Cancel
                    </Button>
                    <Button
                        onClick={handleConfirmDelete}
                        variant="contained"
                        sx={{
                            bgcolor: "#EF4444",
                            textTransform: "none",
                            "&:hover": {
                                bgcolor: "#DC2626",
                            },
                        }}
                    >
                        Yes, delete it!
                    </Button>
                </DialogActions>
            </Dialog>
        </>
    );
};

function CommentsModal({
    isVisible,
    onClose,
    comments,
    postId,
    post,
    onCommentSubmit,
    onDeleteComment,
    onEditComment,
    currentUserName,
}) {
    const [commentText, setCommentText] = useState("");
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [snackbar, setSnackbar] = useState({
        open: false,
        message: "",
        severity: "error",
    });

    // Handle Snackbar Close
    const handleSnackbarClose = () => {
        setSnackbar({ ...snackbar, open: false });
    };

    const handleCommentSubmit = async () => {
        if (!commentText.trim() || isSubmitting) return;

        setIsSubmitting(true);
        try {
            await onCommentSubmit(postId, commentText.trim());
            setCommentText("");
        } catch (error) {
            console.error("Error submitting comment:", error);
            setSnackbar({
                open: true,
                message: "Failed to submit comment.",
                severity: "error",
            });
        } finally {
            setIsSubmitting(false);
        }
    };

    return (
        <>
            <Modal
                open={isVisible}
                onClose={onClose}
                aria-labelledby="modal-modal-title"
                aria-describedby="modal-modal-description"
            >
                <Box sx={style}>
                    <Box sx={{ flexGrow: 1, overflowY: "auto", p: 2 }}>
                        <Box sx={{ mb: 2 }}>
                            <CardHeader
                                avatar={<Avatar src={post?.user?.avatar} />}
                                title={
                                    <Typography variant="subtitle1" fontWeight="bold">
                                        {post?.user?.name}
                                    </Typography>
                                }
                                subheader={post?.time}
                                sx={{ p: 0, mb: 1 }}
                            />
                            <CardContent sx={{ p: 0 }}>
                                <Typography variant="body1" color="text.primary" paragraph>
                                    {post?.content}
                                </Typography>
                                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                                    {post?.selectedTags?.map((tag, index) => (
                                        <Chip key={index} label={tag} size="small" variant="outlined" color="primary" />
                                    ))}
                                </Box>
                                {post?.fileUrl && (
                                    <Box sx={{ mt: 2, maxHeight: 300, overflow: 'hidden', borderRadius: 1 }}>
                                        {post.fileUrl.match(/\.(jpeg|jpg|gif|png|webp)$/) ? (
                                            <img
                                                src={post.fileUrl}
                                                alt="Post content"
                                                style={{ width: "100%", height: "auto", display: "block" }}
                                            />
                                        ) : (
                                            <a href={post.fileUrl} target="_blank" rel="noopener noreferrer">View File</a>
                                        )}
                                    </Box>
                                )}
                            </CardContent>
                        </Box>

                        <Divider sx={{ my: 2 }} />

                        <Typography variant="h6" fontWeight="bold" sx={{ mb: 1 }}>
                            Comments ({comments.length})
                        </Typography>
                        {comments.length > 0 ? (
                            <Box>
                                {comments.map((comment) => (
                                    <Comment
                                        key={comment.id}
                                        comment={comment}
                                        onDelete={onDeleteComment}
                                        onEdit={onEditComment}
                                        currentUserName={currentUserName}
                                    />
                                ))}
                            </Box>
                        ) : (
                            <Typography variant="body2" color="text.secondary">
                                No comments yet. Be the first!
                            </Typography>
                        )}
                    </Box>

                    <Box sx={{ p: 2, borderTop: "1px solid #eee", flexShrink: 0 }}>
                        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                            <TextField
                                placeholder="Add a comment..."
                                variant="outlined"
                                fullWidth
                                size="small"
                                value={commentText}
                                onChange={(e) => setCommentText(e.target.value)}
                                onKeyDown={(e) => {
                                    if (e.key === "Enter" && !e.shiftKey) {
                                        e.preventDefault();
                                        handleCommentSubmit();
                                    }
                                }}
                                disabled={isSubmitting}
                            />
                            <Button
                                variant="contained"
                                color="primary"
                                onClick={handleCommentSubmit}
                                disabled={!commentText.trim() || isSubmitting}
                                sx={{ minWidth: "auto", p: 1.5 }}
                            >
                                {isSubmitting ? (
                                    <CircularProgress size={20} color="inherit" />
                                ) : (
                                    <SendIcon />
                                )}
                            </Button>
                        </Box>
                    </Box>
                </Box>
            </Modal>

            {/* Snackbar للإشعارات */}
            <Snackbar
                open={snackbar.open}
                autoHideDuration={3000}
                onClose={handleSnackbarClose}
                anchorOrigin={{ vertical: "top", horizontal: "center" }}
            >
                <Alert
                    onClose={handleSnackbarClose}
                    severity={snackbar.severity}
                    sx={{
                        width: "100%",
                        bgcolor: "#EF4444",
                        color: "white",
                        "& .MuiAlert-icon": {
                            color: "white",
                        },
                    }}
                    variant="filled"
                >
                    {snackbar.message}
                </Alert>
            </Snackbar>
        </>
    );
}

export default CommentsModal;    

import React, { useEffect, useState } from "react";
import {
  Card,
  CardHeader,
  CardContent,
  CardActions,
  Avatar,
  IconButton,
  Typography,
  Box,
  Divider,
  Chip,
  Button,
  TextField,
  CircularProgress,
  Menu,
  MenuItem,
} from "@mui/material";
import {
  MoreVert as MoreVertIcon,
  Favorite as FavoriteIcon,
  FavoriteBorder as FavoriteBorderIcon,
  ChatBubbleOutline as ChatBubbleOutlineIcon,
  Share as ShareIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
} from "@mui/icons-material";
import dayjs from 'dayjs';
import {useNavigateToProfile} from "../../../hooks/useNavigateToProfile"
// Format comment/post time
const formatTime = (time) => (!time ? "Just now" : dayjs(time).format('DD MMM, hh:mm A'));

// Single Comment Bubble
const CommentBubble = ({ comment }) => (
  <Box sx={{ display: 'flex', gap: 1, mb: 1, minWidth: 0 }}>
    <Avatar src={comment.author?.avatar} sx={{ width: 24, height: 24, flexShrink: 0 }} />
    <Box sx={{
      bgcolor: '#eef1f3',
      borderRadius: '12px',
      p: 1,
      maxWidth: '100%',
      wordBreak: 'break-word',
      flexGrow: 1
    }}>
      <Typography variant="caption" fontWeight="bold">{comment.author.userName}</Typography>
      <Typography variant="body2">{comment.content}</Typography>
      <Typography variant="caption" color="text.secondary" sx={{ display: 'block', textAlign: 'right', mt: 0.5, lineHeight: 1 }}>
        {formatTime(comment.createdAt)}
      </Typography>
    </Box>
  </Box>
);

const ActionButton = ({ icon, label, onClick }) => (
  <Box sx={{ display: 'flex', alignItems: 'center', cursor: onClick ? 'pointer' : 'default' }} onClick={onClick}>
    <IconButton>{icon}</IconButton>
    <Typography variant="body2" color="text.secondary">{label}</Typography>
  </Box>
);

function PostCard({
  post,
  onDelete,
  onEdit,
  onLike,
  onShowComments,
  fetchRecentComments,
  onAddCommentInline
}) {
  const [anchorEl, setAnchorEl] = useState(null);
  const [recentComments, setRecentComments] = useState(post.recentComments || []);
  const [inlineCommentText, setInlineCommentText] = useState('');
  const [isCommenting, setIsCommenting] = useState(false);

  const open = Boolean(anchorEl);
  const currentUserName = localStorage.getItem("userName");
  const isPostAuthor = post.user.name === currentUserName;

  // Load recent comments
  useEffect(() => {
    const loadRecentComments = async () => {
      if (post.comments > 0) {
        const comments = await fetchRecentComments(post.id);
        setRecentComments(comments);
      } else {
        setRecentComments([]);
      }
    };

    if (post.recentComments?.length > 0) {
      setRecentComments(post.recentComments);
    } else {
      loadRecentComments();
    }
  }, [post.id, post.comments, post.recentComments, fetchRecentComments]);

  const handleClick = (event) => setAnchorEl(event.currentTarget);
  const handleClose = () => setAnchorEl(null);
  const handleDeleteClick = () => { onDelete(post.id); handleClose(); };
  const handleEditClick = () => { onEdit(post.id); handleClose(); };
  const handleLikeClick = () => onLike(post.id);
  const handleCommentClick = () => onShowComments(post.id);
 
    const navigateToProfile = useNavigateToProfile();

  const handleInlineCommentSubmit = async (e) => {
    e.preventDefault();
    if (!inlineCommentText.trim()) return;

    setIsCommenting(true);
    try {
      await onAddCommentInline(post.id, inlineCommentText.trim());
      setInlineCommentText('');
    } catch (error) {
      console.error("Error submitting inline comment:", error);
    } finally {
      setIsCommenting(false);
    }
  };
 // دالة للانتقال للبروفايل
  //  const handleNavigateToProfile = () => {
  //        if (!post.user.id) return;
  
  //  const currentUserId = localStorage.getItem("userId");
  
  //  // إذا بروفايلي، روح على /app/profile بدون userId
  //  // حطينا نمبر لأن الـ userId في الـ localStorage مخزن كنص
  //  if (post.user.id === Number(currentUserId)) {
  //    navigate('/app/profile');
  //  } else {
  //    // إذا بروفايل شخص تاني، مرر الـ userId
  //    navigate(`/app/profile/${post.user.id}`);
  //  }
  // };
  return (
    <Card sx={{ mb: 3, borderRadius: 2, boxShadow: "0 4px 12px rgba(0,0,0,0.1)" }}>
      {/* Header */}
      <CardHeader
        avatar={<Avatar src={post.user.avatar} />}
        action={isPostAuthor && (
          <IconButton aria-label="settings" onClick={handleClick}><MoreVertIcon /></IconButton>
        )}
        title={
        <Typography variant="subtitle1" fontWeight="bold" 
          sx={{ 
              cursor: 'pointer',
              '&:hover': { 
                textDecoration: 'underline',
                color: 'primary.main'
              }
            }}     
           onClick={() => navigateToProfile(post.user.id)}>
            {post.user.name}
            </Typography>}
        subheader={post.time}
      />

      {/* Menu */}
      <Menu anchorEl={anchorEl} open={open} onClose={handleClose}>
        <MenuItem onClick={handleEditClick}><EditIcon fontSize="small" sx={{ mr: 1 }} /> Edit Post</MenuItem>
        <MenuItem onClick={handleDeleteClick}><DeleteIcon fontSize="small" sx={{ mr: 1 }} /> Delete Post</MenuItem>
      </Menu>

      {/* Content */}
      <CardContent>
        <Typography variant="body1" color="text.primary" paragraph>{post.content}</Typography>
        <Box sx={{ mb: 1, display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
          {post.selectedTags.map((tag, index) => (
            <Chip key={index} label={tag} size="small" variant="outlined" color="primary" />
          ))}
        </Box>
        {post.fileUrl && (
          <Box sx={{ mt: 2, maxHeight: 400, overflow: 'hidden', borderRadius: 1 }}>
            <img
              src={post.fileUrl}
              alt="Post content"
              style={{ width: "100%", height: "auto", display: "block" }}
            />
          </Box>
        )}
      </CardContent>

      <Divider />

      <CardActions disableSpacing sx={{ justifyContent: "space-around" }}>
        <ActionButton icon={post.isLiked ? <FavoriteIcon color="error" /> : <FavoriteBorderIcon />} label={`${post.likes} Likes`} onClick={handleLikeClick} />
        <ActionButton icon={<ChatBubbleOutlineIcon />} label={`${post.comments} Comments`} onClick={handleCommentClick} />
        <ActionButton icon={<ShareIcon />} label={`${post.shares} Shares`} />
      </CardActions>

      <Divider />

      {/* Comments */}
      <Box sx={{ px: 2, pb: 1, pt: 1, bgcolor: '#fbfbfb' }}>
        {recentComments.length > 0 && recentComments.map((comment, index) => (
          <CommentBubble key={comment.id || index} comment={comment} />
        ))}

        {post.comments > recentComments.length && (
          <Button variant="text" size="small" onClick={handleCommentClick} sx={{ justifyContent: 'flex-start', p: 0, mb: 1, fontWeight: 'bold' }}>
            VIEW ALL {post.comments} COMMENTS
          </Button>
        )}

        {/* Inline Comment */}
        <Box component="form" onSubmit={handleInlineCommentSubmit} sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Avatar src={post.user.avatar} sx={{ width: 32, height: 32 }} />
          <TextField
            placeholder="Add a comment..."
            variant="outlined"
            fullWidth
            size="small"
            value={inlineCommentText}
            onChange={(e) => setInlineCommentText(e.target.value)}
            disabled={isCommenting}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleInlineCommentSubmit(e);
              }
            }}
          />
          <IconButton type="submit" color="primary" disabled={!inlineCommentText.trim() || isCommenting} size="small">
            {isCommenting ? <CircularProgress size={20} /> : <ChatBubbleOutlineIcon fontSize="small" />}
          </IconButton>
        </Box>
      </Box>
    </Card>
  );
}